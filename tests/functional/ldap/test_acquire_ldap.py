from unittest.mock import MagicMock, mock_open, patch

import pytest

import sarc.account_matching.make_matches
import sarc.ldap.acquire
import sarc.ldap.read_mila_ldap  # will monkeypatch "query_ldap"
from sarc.config import config
from sarc.ldap.api import get_user

from .test_read_mila_ldap import fake_raw_ldap_data


# @pytest.mark.usefixtures("read_write_db")
@pytest.mark.usefixtures("empty_read_write_db")
def test_acquire_ldap(monkeypatch):
    """
    Override the LDAP queries.
    Have users with matches to do.
        (at least we don't need to flex `perform_matching` with edge cases)
    Inspect the results in the database to make sure they're all there.
    """

    cfg = config()
    nbr_users = 10

    def mock_query_ldap(ldap, *args):
        assert ldap.ldap_service_uri.startswith("ldaps://")
        return fake_raw_ldap_data(nbr_users)

    monkeypatch.setattr(sarc.ldap.read_mila_ldap, "query_ldap", mock_query_ldap)

    # We also need to generate the data for the two files being read:
    #     cfg.account_matching.cc_roles_csv_path
    #     cfg.account_matching.cc_members_csv_path
    #
    # We will define the content we want to inject for each file.
    # These are based on the fake users generated by `fake_raw_ldap_data`.
    # We don't need to create weird edge cases, because we are not testing
    # the details of the matching algorithm here. We are testing the pipeline.
    #
    # Naturally, the content of the CSV files must be consistent with the
    # fake users defined by `fake_raw_ldap_data`.
    # We'll add an extra use that won't match, called "Mysterious Stranger".

    # inspired by sponsored_roles_for_Yoshua_Bengio_(CCI_jvb-000).csv
    file1_content = """"Status","Username","Nom","Email","État du compte"
"Activated","john.smith000","John Smith the 000rd","js000@yahoo.ca","activé"
"Activated","john.smith001","John Smith the 001rd","js001@yahoo.ca","activé"
"Activated","john.smith002","John Smith the 002rd","js002@yahoo.ca","activé"
"Activated","stranger.person","Mysterious Stranger","ms@hotmail.com","activé"
"""
    # inspired by members-rrg-bengioy-ad-2022-11-25.csv
    file2_content = """Name,Sponsor,Permission,Activation_Status,username,Email
John Smith the 000rd,BigProf,Manager,activated,john.smith000,js000@yahoo.ca
John Smith the 001rd,BigProf,Manager,activated,john.smith001,js001@yahoo.ca
John Smith the 002rd,BigProf,Manager,activated,john.smith002,js002@yahoo.ca
Mysterious Stranger,BigProf,Manager,activated,stranger.person,ms@hotmail.com
"""
    # inspired by make_matches_config.json
    file3_content = """
{
    "L_phantom_mila_emails_to_ignore":
        [
            "john.smith005@mila.quebec",
            "john.smith006@mila.quebec"
        ],
    "D_override_matches_mila_to_cc_account_username":
        {
            "john.smith008@mila.quebec": "smith000"
        }
}
"""

    # Create a dictionary of file paths and their corresponding content
    file_contents = {
        cfg.account_matching.cc_roles_csv_path: file1_content,
        cfg.account_matching.cc_members_csv_path: file2_content,
        cfg.account_matching.make_matches_config: file3_content,
    }

    # Define a function that returns a new mock file object with the content
    def mock_file(filename, *vargs, **kwargs):
        if filename in file_contents:
            return mock_open(read_data=file_contents[filename]).return_value
        else:
            # we haven't found a way to pass through the other calls
            # to `open` other files, so let's just raise an error
            # because those aren't going to work anyways
            raise FileNotFoundError(filename)

    # Patch the built-in `open()` function for each file path
    with patch("builtins.open", side_effect=mock_file):
        sarc.ldap.acquire.run()

    # Validate the results of all of this by inspecting the database.
    for i in range(3):
        js_user = get_user(mila_email_username=f"john.smith{i:03d}@mila.quebec")
        assert js_user is not None
        # L = list(
        #    cfg.mongo.database_instance[cfg.ldap.mongo_collection_name].find(
        #        {"mila_ldap.mila_email_username": f"john.smith{i:03d}@mila.quebec"}
        #    )
        # )

        # test some cc_roles and cc_members fields
        for segment in ["cc_roles", "cc_members"]:
            assert segment in js_user
            assert "email" in js_user[segment]
            assert js_user[segment]["email"] == f"js{i:03d}@yahoo.ca"
            assert "username" in js_user[segment]
            assert js_user[segment]["username"] == f"john.smith{i:03d}"

    # test the absence of the mysterious stranger
    js_user = get_user(drac_account_username="ms@hotmail.com")
    assert js_user is None
